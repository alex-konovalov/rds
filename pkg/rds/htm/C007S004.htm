<html><head><title>[RDS] 7.4 Invariants for Projective Planes</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "C007S000.htm">Up</a>] [<a href ="C007S003.htm">Previous</a>] [<a href ="C008S000.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>7.4 Invariants for Projective Planes</h1><p>
<p>
The functions <code>NrFanoPlanesAtPoints</code>, <code>pRank</code>, <code>FingerprintAntiFlag</code>
and <code>FingerprintProjPlane</code> calculate invariants for finite projective
planes. For more details see <a href="biblio.htm#RoederDiss"><cite>RoederDiss</cite></a> and
<a href="biblio.htm#MoorhouseGraphs"><cite>MoorhouseGraphs</cite></a>. The values of some of these invariants are
available from the homepages of <a href="biblio.htm#Moorhouse"><cite>Moorhouse</cite></a> and <a href="biblio.htm#Royle"><cite>Royle</cite></a> for
many planes.
<p>
<a name = "SSEC1"></a>
<li><code>NrFanoPlanesAtPoints( </code><var>points</var><code>, </code><var>data</var><code> ) O</code>
<p>
For a projective plane defined by the blocks  <var>data</var> as returned 
by <code>ElationPrecalc</code>, <code>NrFanoPlanesAtPoints(</code><var>points</var><code>,</code><var>data</var><code>)</code> 
calculates the so-called Fano invariant. That is, for each point 
in <var>points</var>, the number of subplanes of order 2 (so-called Fano planes)
containing this point is calculated.
The method returns a list of pairs of the form [<i>point</i> ,<i>number</i> ]
where <var>number</var> is the number of Fano sub-planes in <var>point</var>.
<p>
<a name = "SSEC2"></a>
<li><code>NrFanoPlanesAtPointsSmall( </code><var>pointlist</var><code>, </code><var>data</var><code> ) O</code>
<p>
Uses <var>data</var> as returned by <code>ElationPrecalcSmall</code>. Only use this, if you
want to do a quick experiment in a plane of <strong>small</strong> order and don't like
to generate a new set of data with <code>ElationPrecalc</code>. The difference
between <code>NrFanoPlanesAtPoints</code> and <code>NrFanoPlanesAtPointsSmall</code> is that
the ``small'' version does some operations for lists (like <code>Intersection</code>)
whereas the ``large'' version does only read matrix entries. This makes
quite a difference as for a plane of order <i>n</i>, there are 
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"></td><td align="left" class="cl">&#63723;<br />&#63725;</td><td nowrap="nowrap" align="center"><i>n</i>+1<br />3<br /></td><td align="left" class="cl">&#63734;<br />&#63736;</td><td nowrap="nowrap" align="center"></td><td align="left" class="cl">&#63723;<br />&#63725;</td><td nowrap="nowrap" align="center"><i>n</i><br />2<br /></td><td align="left" class="cl">&#63734;<br />&#63736;</td><td nowrap="nowrap" align="center"><i>n</i></td></tr></table></td></tr></table> quadrangles to be tested per point.
<p>
<a name = "SSEC3"></a>
<li><code>IncidenceMatrix( </code><var>points</var><code>, </code><var>blocks</var><code> ) O</code>
<li><code>IncidenceMatrix( </code><var>data</var><code> ) O</code>
<p>
returns a matrix <var>I</var>, where the columns are numbered by the blocks and
the rows are numbered by points. And <var>I[i][j]=1</var> if and only if 
<var>points[i]</var> is incident (contained in) <var>blocks[j]</var>.
<p>
<a name = "SSEC4"></a>
<li><code>pRank( </code><var>blocklist</var><code>, </code><var>p</var><code> ) O</code>
<li><code>pRank( </code><var>data</var><code>, </code><var>p</var><code> ) O</code>
<p>
Let <var>I</var> be the incidence matrix of the projective plane given by  the list
of blocks <var>blocklist</var> or the record <var>data</var> as returned by 
<code>ElationPrecalc</code>. The rank of <i>I</i>&#183;<i>I</i><sup><i>t</i></sup> as a matrix over
<i>GF</i>(<i>p</i>) is called  <var>p</var>-rank of the projective plane. Here <i>I</i><sup><i>t</i></sup> denotes
the transposed matrix.
<p>
As <code>pRank</code> calls <code>IncidenceMatrix</code>, the list <var>blocklist</var> has to be a list 
of lists of integers.
<p>
<a name = "SSEC5"></a>
<li><code>FingerprintProjPlane( </code><var>blocks</var><code> ) O</code>
<li><code>FingerprintProjPlane( </code><var>data</var><code> ) O</code>
<p>
For each anti-flag (<i>p</i>,<i>l</i>) of a projective plane of order <i>n</i>, 
define an arbitrary but fixed enumeration of the lines through <i>p</i> and 
the points on <i>l</i>. Say <i>l</i><sub>1</sub>,...,<i>l</i><sub><i>n</i>+1</sub> and <i>p</i><sub>1</sub>,...,<i>p</i><sub><i>n</i>+1</sub>
The incidence relation defines a canonical bijection between the <i>l</i><sub><i>i</i></sub> and
the <i>p</i><sub><i>i</i></sub> and hence a permutation on the indices 1,...,<i>n</i>+1. 
Let &#963;<sub>(<i>p</i>,<i>l</i>)</sub> be this permutation.
<p>
Denote the points and lines of the plane by <i>q</i><sub>1</sub>,... <i>q</i><sub><i>n</i><sup>2</sup>+<i>n</i>+1</sub> 
and <i>e</i><sub>1</sub>,...,<i>e</i><sub><i>n</i><sup>2</sup>+<i>n</i>+1</sub>. 
Define the sign matrix as <i>A</i><sub><i>ij</i></sub>=<i>sgn</i>(&#963;<sub>(<i>q</i><sub><i>i</i></sub>,<i>e</i><sub><i>j</i></sub>)</sub>) if (<i>q</i><sub><i>i</i></sub>,<i>e</i><sub><i>j</i></sub>) 
is an anti-flag and =0 if it is a flag.
Then the fingerprint is defnied as the multiset of the entries of &#124;<i>AA</i><sup><i>t</i></sup>&#124;.
Here <var>data</var> is a record as returned by <code>ElationPrecalcSmall</code>.
<p>
<a name = "SSEC6"></a>
<li><code>FingerprintAntiFlag( </code><var>point</var><code>, </code><var>linenr</var><code>, </code><var>data</var><code> ) O</code>
<p>
Let <i>m</i><sub>1</sub>,...,<i>m</i><sub><i>n</i>+1</sub> be the lines containing <var>point</var> and 
<i>E</i><sub>1</sub>,...,<i>E</i><sub><i>n</i>+1</sub> the points on the line given by <var>linenr</var> such that
<i>E</i><sub><i>i</i></sub> is incident with <i>m</i><sub><i>i</i></sub>. Now label the points of <i>m</i><sub><i>i</i></sub> as 
<i>point</i> =<i>P</i><sub><i>i</i>,1</sub>,...,<i>P</i><sub><i>i</i>,<i>n</i>+1</sub>=<i>E</i><sub><i>i</i></sub> and the lines of <i>E</i><sub><i>i</i></sub> as
<i>line</i> =<i>l</i><sub>1</sub>,...,<i>l</i><sub><i>i</i>,<i>n</i>+1</sub>=<i>m</i><sub><i>i</i></sub>. 
For <i>i</i> &#8800; <i>j</i>, each <i>P</i><sub><i>j</i>,<i>k</i></sub> lies on exactly one line 
<i>l</i><sub><i>i</i>,<i>k</i>&#963;<sub><i>i</i>,<i>j</i></sub></sub> containing <i>E</i><sub><i>i</i></sub> for some permutation &#963;<sub><i>i</i>,<i>j</i></sub>
<p>
Define a matrix <i>A</i>, where <i>A</i><sub><i>i</i>,<i>j</i></sub> is the sign of &#963;<sub><i>i</i>,<i>j</i></sub> if 
<i>i</i> &#8800; <i>j</i> and <i>A</i><sub><i>i</i>,<i>i</i></sub>=0 for all <i>i</i>.
The partial fingerprint is the multiset of entries of &#124;<i>AA</i><sup><i>t</i></sup>&#124; where <i>A</i><sup><i>t</i></sup> 
denotes the transposed matrix of <i>A</i>.
<p>
this is a ``small'' function.
<p>
<p>
[<a href = "C007S000.htm">Up</a>] [<a href ="C007S003.htm">Previous</a>] [<a href ="C008S000.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>RDS manual<br>November 2006
</address></body></html>