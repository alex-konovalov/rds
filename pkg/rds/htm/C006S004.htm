<html><head><title>[RDS] 6.4 Methods for calculating ordered signatures</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "C006S000.htm">Up</a>] [<a href ="C006S003.htm">Previous</a>] [<a href ="C007S000.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>6.4 Methods for calculating ordered signatures</h1><p>
<p>
<a name = "SSEC1"></a>
<li><code>NormalSubgroupsForRep( </code><var>groupdata</var><code>, </code><var>divisor</var><code> ) O</code>
<p>
Let <var>groupdata</var> be the output of <code>PermutationRepForDiffsetCalculations</code> and 
<var>divisor</var> an integer. Then <code>NormalSubgroupsForRep</code> calculates all  normal 
subgroups of <var>groupdata.G</var> such that the size of the factor group is divisible 
by <var>divisor</var> and the factor group is a semidirect product of cyclic groups.
<p>
The output is a record consisting of 
<dl compact>
 <dt>1.<dd>a normal subgroup <var>.Nsg</var> of <var>G</var>
 <dt>2.<dd>the factor group <var>.fgrp</var>:=<var>G</var>/<var>Nsg</var> 
 <dt>3.<dd>the epimorphism <var>.epi</var> from <var>G</var> to <var>.fgrp</var>
 <dt>4.<dd>a root of unity <var>.root</var>
 <dt>5.<dd>a galois automorphism <var>.alpha</var>
 <dt>6.+7.<dd>generators of the factor group <var>G</var>/<var>.Nsg</var> named <var>.a</var> and <var>.b</var> 
           such that <var>.a</var> is normalized by <var>.b</var>.
 <dt>8<dd>a list <var>.int2pairtable</var> such that the <i>i</i><sup><i>th</i></sup> entry ist the pair 
           <var>[m,n]</var> with that <var>Glist[i]^epi=a^(m-1)*b^(n-1)</var>
</dl>
<p>
<var>.alpha</var> and <var>.root</var> may be used as input for <code>OrderedSigs</code>
<p>
<a name = "SSEC2"></a>
<li><code>OrderedSigs( </code><var>coeffSums</var><code>, </code><var>absSum</var><code>, </code><var>alpha</var><code>, </code><var>root</var><code> ) O</code>
<p>
Let <i>G</i> be group which contains a normal subgroup of index <i>s</i> such that 
the coset signature for a difference set for this normal subgroup is 
<var>coeffSums</var>. Let <i>N</i> be a normal subgroup of <i>G</i> such that <i>G</i>/<i>N</i> is a 
semidirect product of cyclic group of orders <i>s</i>,<i>q</i>  and 
<i>i</i> divides the order of <i>G</i>/<i>N</i>. 
<p>
Then <code>OrderedSigs(</code><var>coeffSums</var><code>,</code><var>absSum</var><code>,</code><var>alpha</var><code>,</code><var>root</var><code>)</code> calculates 
all ordered signatures for <i>N</i>. Here <var>root</var> is a primitive <i>q</i>-th root 
of unity and <var>alpha</var> is a Galois- automorphism of <i>CS</i>(<i>q</i>) with order 
dividing <i>s</i>. <var>absSum</var> is the order of the difference set.
(i.e. <i>order</i>=<i>k</i>&#8722;&#955;).
<p>
<code>OrderedSigs</code> is based on calculations using an <i>s</i>-dimensional unitary 
representation of <i>G</i>/<i>N</i>. 
In this representation a subset of <i>G</i> induces a semi-circular matrix.
The returned value is a list of lists <i>s</i>-tuples
The entries of the <i>s</i>-tuples are coefficients of  numbers in 
<b>Z</b>[<i>root</i> ] such that the semi-circular matrix defined by these numbers
together with <var>alpha</var> meets necessary conditions for matrices induced
by difference sets.
To gain the algebraic numbers from the <i>s</i>-tuple <var>tup</var>, use 
<code>List(</code><var>tup</var><code>,i-&gt;CoeffList2CyclotomicList(i,</code><var>root</var><code>))</code>
<p>
Each &#124;<i>coeffSums</i> &#124;-tuple returned defines an ordered signature. The ordering
of <i>G</i>/<i>N</i> is chosen to fit to the data returned by <code>NormalSubgroupsForRep</code>:
<p>
[<i>a</i><sup>0</sup>,<i>a</i><sup>1</sup>,...,<i>a</i><sup><i>q</i>&#8722;1</sup>],[<i>a</i><sup>0</sup><i>b</i>,<i>a</i><sup>1</sup><i>b</i>,...,<i>a</i><sup><i>q</i>&#8722;1</sup><i>b</i>],...,[<i>a</i><sup>0</sup><i>b</i><sup><i>s</i>&#8722;1</sup>,...,<i>a</i><sup><i>q</i>&#8722;1</sup><i>b</i><sup><i>s</i>&#8722;1</sup>]
<p>
So for the calculation of ordered signatures, smaller ordered
signatures <var>coeffSums</var> have to be known. But this is not so bad, as
small signatures are easy to calculate.
The following example shows an application.
<p>
<pre>
gap&gt; G:=SmallGroup(273,3);                              
&lt;pc group of size 273 with 3 generators&gt;
gap&gt; Gdata:=PermutationRepForDiffsetCalculations(G);;
gap&gt; CosetSignatures(273,273/3,16);
[ [ 3, 7, 7 ] ]
gap&gt; nsgs:=NormalSubgroupsForRep(Gdata,3);           
[ rec( Nsg := Group([ f2 ]), alpha := ANFAutomorphism( CF(13), 3 ), 
      root := E(13), fgrp := Group([ f1, &lt;identity&gt; of ..., f2 ]), 
      epi := [ f1, f2, f3 ] -&gt; [ f1, &lt;identity&gt; of ..., f2 ], a := f2, 
      b := f1, 
      int2pairtable := [ [ 1, 1 ], [ 1, 2 ], [ 1, 1 ], [ 2, 1 ], [ 1, 3 ], 
...
          [ 8, 3 ], [ 11, 3 ], [ 5, 2 ], [ 11, 3 ] ] ), 
  rec( Nsg := Group([ f3 ]), alpha := ANFAutomorphism( CF(7), 2 ), 
      root := E(7), fgrp := Group([ f1, f2, &lt;identity&gt; of ... ]), 
      epi := [ f1, f2, f3 ] -&gt; [ f1, f2, &lt;identity&gt; of ... ], a := f2, 
      b := f1, 
      int2pairtable := [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 1, 1 ], [ 1, 3 ], 
...
          [ 6, 3 ], [ 4, 3 ], [ 4, 2 ], [ 6, 3 ] ] ) ]
gap&gt; osigs:=OrderedSigs([3,7,7],16,nsgs[2].alpha,nsgs[2].root);
[ [ [ 0, 0, 0, 1, 0, 1, 1 ], [ 0, 0, 1, 2, 2, 0, 2 ], [ 2, 2, 0, 2, 0, 0, 1 ] ], 
  [ [ 0, 0, 0, 1, 0, 1, 1 ], [ 0, 1, 2, 2, 0, 2, 0 ], [ 2, 0, 0, 1, 2, 2, 0 ] ], 
...
   [ [ 1, 1, 0, 1, 0, 0, 0 ], [ 2, 2, 1, 0, 0, 2, 0 ], [ 2, 1, 0, 0, 2, 0, 2 ] ] ]
gap&gt; Size(osigs);
98
gap&gt; Set(osigs,g-&gt;SortedList(Concatenation(g)));
[ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2 ] ]
</pre>
<p>
Note that the signature <code>[3, 7, 7]</code> can be assumed to be ordered (by
passing to a suitable translate). So even if we are not interested in
<strong>ordered</strong> signatures, we have found out that there is only one admissible
unordered signature for this normal subgroup. To get this result using
<code>TestedSignatures</code> would have taken a <strong>very</strong> long time.
<p>
Of course, ordered signatures can also be used directly.
<p>
<a name = "SSEC3"></a>
<li><code>OrderedSignatureOfSet( set, normal_data ) O</code>
<p>
takes a set <var>set</var> of integers (meant to be a partial difference set) and
a list of records as returned by <code>NormalSubgroupsForRep</code>.
The returned value is a list of lists which is the ordered signature of the
partial difference set <var>set</var> and can be compared to the output of <code>OrderedSigs</code>
<p>
<pre>
gap&gt; OrderedSignatureOfSet([2,3,4,5],nsgs[2]);  
[ [ 1, 1, 1, 0, 0, 0, 0 ], [ 1, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0 ] ]
</pre>
<p>
<p>
[<a href = "C006S000.htm">Up</a>] [<a href ="C006S003.htm">Previous</a>] [<a href ="C007S000.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>RDS manual<br>November 2006
</address></body></html>