% This file was created automatically from startsets.msk.
% DO NOT EDIT!
\Chapter{General concepts}

In this chapter, we first give a definition of relative difference
sets and outline a part of the theory. Then we have a quick look at
the way difference sets are represented in {\RDS}.

After that, some basic methods for the generation of difference sets
are explained. 

If you already read chapter "RDS:A quick start" and want to know what
`StartsetsInCoset' really does, you may want to read this chapter (and
the following one, of course). The main high-level function in this
chapter is `ExtendedStartsets'.


%%%%%%%%%%%%%%%%%%%%
\Section{Introduction}

\Input{rds}

%%%%%%%%%%%%%%%%%%%%
\Section{How partial difference sets are represented}

Let $G$ be a group. We define an enumeration $\{g_1,\dots,g_n\}=G$ and
represent $D\subseteq G$ as a list of integers (where ,of course, $i$
represents $g_i$ for all $1\leq i\leq n$).  So the automorphism group
of $G$ is represented as a permutation group of degree $n$.  One of
the operations performed most often by methods in {\RDS} is
the calculation of quotients in $G$. So we calculate a look-up
table for this.

This pre-calculation is done by the operation
`PermutationRepForDiffsetCalcuations'. So before you start generating
difference set, call this function and work with the data structure
returned by it.

For an exhaustive search, the ordering of $G$ is very important. To
avoid generating duplicate partial difference sets, we would like to
represent partial difference sets by *sets*, i.e. ordered lists. But
in fact, {\RDS} does *not* assume that partial difference
sets are sets. The operations `ExtendedStartSets' and `AllDiffsets'
assume that the last element of partial difference set is its
maximum. But they don't test it. So if you start from scratch, these
methods generate difference sets which are really sets. Whereas the
`NoSort' versions disregard the ordering of $G$ and will produce
duplicates.

The reason for this seemingly strange behaviour is the following:
Assume that we have a normal subgroup $U\leq G$ and know that every
difference set $D\subseteq G$ contains exactly $n_i$ elements from the
$i^{\rm th}$ coset modulo $U$. Then it is natural to generate
difference sets by first searching all partial difference sets of
length $n_1$ containing entirely of elements of the first coset modulo
$U$ and then proceed with the other cosets. 

This method of difference set generation is normally not compatible
with the ordering of $G$. This is why partial difference sets are not
required to be *sets*. See chapter "RDS:An Example Program" for an
example.


%%%%%%%%%%%%%%%%%%%%
\Section{Basic functions for startset generation}

Defining an enumeration of the a group $G$, every relative difference
set may be represented by a list of integers. Indexing $G$ in this way
has the advantage of the automorphism group of $G$ being a permutation
group. As relative difference sets are normally calculated in small
groups, it is possible to store a complete multiplication table of the
group in terms of the enumeration.  

If not stated otherwise, partial difference sets are always considered
to be lists of integers. Note that it is not required for a partial
difference set to be a set.

\>PermutationRepForDiffsetCalculations( <group> ) O
\>PermutationRepForDiffsetCalculations( <group>, <autgrp> ) O

For a group <group>, `PermutationRepForDiffsetCalculations(<group>)'
returns a record containing:
\beginlist
 \item{1.} the group <.G>=<group>.
 \item{2.} the sorted list <.Glist>=`Set(<group>)',
 \item{3.} the automorphism group <.A> of <group>,
 \item{4.} the group <.Aac>, which is the permutation action of <A> on the indices of <.Glist>,
 \item{5.} <.Ahom>=`ActionHomomorphism(<.A>,<.Glist>)',
 \item{6.} the group <.Ai> of anti-automorphisms of <.group> acting on the indices of <Glist>,
 \item{7.} the multiplication table <.diffTable> of <.group> in a special form.
\endlist

<.diffTable> is a matrix of integers defined such that 
`<.difftable>[i][j]' is the position of `<Glist>[i](<Glist>[j])^{-1})'
in <Glist> with `<Glist>[1]=One(<group>)'.

`PermutationRepForDiffsetCalculations' runs into an error if 
`Set(<group>)[1]' is not equal to `One(<group>)'.

If <autgrp> is given, `PermutationRepForDiffsetCalculations' will not calculate the
automorphism group of <group> but will take <autgrp> instead without any test.



If 'Set(<group>)[1]' is not equal to `One(<group>)', then
`PermutationRepForDiffsetCalculations' returns an error message
stating ``Unable to generate <Glist>''. In this case, calculating a
representation helps:

\beginexample
gap> G:=DirectProduct(SL(2,3),CyclicGroup(3));
<group of size 72 with 3 generators>
gap> data:=PermutationRepForDiffsetCalculations(G);
Error, Unable to generate <Glist>
 called from
<function>( <arguments> ) called from read-eval-loop
Entering break read-eval-print loop ...
you can 'quit;' to quit to outer loop, or
you can 'return;' to continue
brk> quit;
gap> phi:=ActionHomomorphism(G,Set(G),OnRight);
<action homomorphism>
gap> Gnew:=ImagesSource(phi);
<permutation group with 3 generators>
gap> data:=PermutationRepForDiffsetCalculations(Gnew);
\endexample

A partial difference set may be converted from a list of group
elements to a list of integers using 
\>GroupList2PermList( <list>, <dat> ) O



where <dat> is a record containing <.diffTable> as returned by
`PermutationRepForDiffsetCalculations'. The inverse operation is
performed by 
\>PermList2GroupList( <list>, <dat> ) O




\beginexample
gap>  G:=DihedralGroup(6);
<pc group of size 6 with 2 generators>
gap> N:=NormalSubgroups(G)[2];
Group([ f2 ])
gap> dat:=PermutationRepForDiffsetCalculations(G);
rec( G := <pc group of size 6 with 2 generators>, 
  Glist := [ <identity> of ..., f1, f2, f1*f2, f2^2, f1*f2^2 ], 
  A := <group of size 6 with 2 generators>, 
  Aac := Group([ (3,5)(4,6), (2,4,6) ]), 
  Ahom := <action homomorphism>, 
  Ai := Group([ (3,5), (3,5)(4,6), (2,4,6) ]), 
  diffTable := [ [ 1, 2, 5, 4, 3, 6 ], [ 2, 1, 6, 3, 4, 5 ], 
      [ 3, 6, 1, 2, 5, 4 ], [ 4, 5, 2, 1, 6, 3 ], 
      [ 5, 4, 3, 6, 1, 2 ], [ 6, 3, 4, 5, 2, 1 ] ] )
gap> Nperm:=GroupList2PermList(Set(N),dat);
[ 1, 3, 5 ]
\endexample

In the following functions the record <dat> has to contain a matrix
<.diffTable> as returned by `PermutationRepForDiffsetCalculations'.

\>NewPresentables( <list>, <newel>, <table> ) O
\>NewPresentables( <list>, <newel>, <dat> ) O
\>NewPresentables( <list>, <newlist>, <dat> ) O
\>NewPresentables( <list>, <newlist>, <table> ) O

`NewPresentables( <list>,<newel>,<dat> )' takes a record <dat> as 
returned by `PermutationRepForDiffsetCalculations(<group>)'.
For `NewPresentables( <list>,<newel>,<table> )', <table> has to be the
multiplication table in the form of  
`NewPresentables( <list>,<newel>,<dat.diffTable>)'

The method returns the unordered list of quotients $d_1<newel>^{-1}$ with 
$d_1\in <list>\cup\{1\}$ (in permutation representation).

When used with a list <newlist>, a list of quotients $d_1d_2^{-1}$ with 
$d_1\in <list>\cup\{1\}$ and $d_2\in <newlist>$ is returned.


\>AllPresentables( <list>, <table> ) O
\>AllPresentables( <list>, <dat> ) O

Let <list> be a list of integers representing elements of a group defined 
by <dat> (or <table>).
`AllPresentables( <list>,<table>)' returns an unordered list of 
quotients $ab^{-1}$ for all group elements $a,b$  represented by integers 
in <list>. If $1\in <list>$, an error is issued.
The multiplication table <table> has to be of the form as returned by 
`PermutationRepForDiffsetCalculations'. And <dat> is a record as 
calculated by `PermutationRepForDiffsetCalculations'.


%
\beginexample
gap> G:=CyclicGroup(7);;dat:=PermutationRepForDiffsetCalculations(G);;
gap> AllPresentables([2,3],dat);
[ 2, 3, 7, 2, 7, 6 ]
gap> AllPresentables([1,2,3],dat);
Error...
\endexample
%	
\>RemainingCompletions( <diffset>, <completions>[, <forbidden>], <dat>[, <lambda>] ) O
\>RemainingCompletionsNoSort( <diffset>, <completions>[, <forbidden>], <table>[, <lambda>] ) O

For a partial difference set <diffset>, 
`RemainingCompletions(<diffset>,<completions>,<dat>)' returns a 
subset of the *set* <completions>, such that each of its elements may be 
added to <diffset> without it loosing the property to be a partial 
difference set. 
Only elements greater than the last element of <diffset> are returned.

For partial *relative* difference sets, <forbidden> is the forbidden set.

`RemainingCompletionsNoSort' does also return elements from <completions> which
are smaller than `<diffset>[Size(<diffset>)]'. 


\beginexample
gap> G:=CyclicGroup(7);
<pc group of size 7 with 1 generators>
gap> dat:=PermutationRepForDiffsetCalculations(G);;
gap> RemainingCompletionsNoSort([4],[1..7],dat);
[ 2, 3 ]
gap> RemainingCompletionsNoSort([4],[1..7],dat,2);
[ 2, 3, 6, 7 ]
gap> RemainingCompletions([4],[1..7],dat);        
[  ]
gap> RemainingCompletions([4],[1..7],dat,2);
[ 6, 7 ]
\endexample

\>ExtendedStartsets( <startsets>, <completions>, [<forbiddenset>][, <aim>], <Gdata>[, <lambda>] ) O
\>ExtendedStartsetsNoSort( <startsets>, <completions>, [<forbiddenset>][, <aim>], <Gdata>[, <lambda>] ) O

For a set of partial (relative) difference sets <startsets>, the set of 
all extensions by one element from <completions> is returned.
Here an ``extension'' of a partial diffence set $S$ is a list which has 
one element more than $S$ and contains $S$.

Here <completions> is a set of elements wich may be appended to the lists in 
<startsets> to generate new partial difference sets. For relative difference
sets, the forbidden set <forbiddenset> must be given. 
And the integer <aim> gives the desired total length, i.e. the number 
of elements of <completions> that have to be added to each startset 
plus its length. Note that the elements of <startset> are always extended
by *one* element (if they can be extended). <aim> does only tell how 
many elements from <completions> you want to add. A partial difference
set is only be extended, if there are enough admissible elements in 
<completions>, so if for some $S\in<startsets>$, we have less than 
$<aim>-`Size'(S)$ elements in <completions> which can be added to $S$,
no extension of $S$ is returned. 

If <lambda> is not passed as a parameter, it is assumed to be $1$.

Note that `ExtendedStartsets' does use `RemainingCompletions' while 
`ExtendedStartsetsNoSort' uses `RemainingCompletionsNoSort'. 
Note that the partial difference sets generated with `ExtendedStartsetsNoSort'
are *not* sets (i.e. not sorted). This may result in doing work
twice. But it can also be useful, especially when generating difference sets 
``coset by coset''.



\beginexample
gap> G:=CyclicGroup(7);;dat:=PermutationRepForDiffsetCalculations(G);;
gap> startsets:=[[2],[4],[6]];;
gap> ExtendedStartsets(startsets,[1..7],dat);
[ [ 2, 4 ], [ 2, 6 ] ]
gap> ExtendedStartsets(startsets,[1..7],3,dat);
[ [ 2, 4 ] ]
gap> ExtendedStartsets(startsets,[1..7],dat,2);
[ [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], [ 2, 6 ], [ 4, 6 ], [ 4, 7 ], [ 6, 7 ] ]
gap> ExtendedStartsetsNoSort(startsets,[1..7],dat);
[ [ 2, 4 ], [ 2, 6 ], [ 4, 2 ], [ 4, 3 ], [ 6, 2 ], [ 6, 5 ] ]
\endexample

%%%%%%%%%%%%%%%%%%%%
\Section{A brute force method}

The following method can be used to find (partial) difference sets by
brute force.

\>AllDiffsets( <diffset>, <completions>, <aim>, <forbidden>, <Gdata>, <lambda> ) O

Let <diffset> be partial relative difference set and <completions> a list
of possible completions and <forbidden> the forbidden set. Then
`AllDiffsets' returns a list of (partial) difference sets which contain
diffset. <Gdata> is the record as always and <lambda> is the parameter
of the relative difference set. <forbidden> and <completions> have to be
lists of integers.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E END startsets.msk
%%